# -*- coding: utf-8 -*-
"""PROJECT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Gi-1P7KLpPtxfGVNscbIysc-di7CJJx_
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
sns.set(style = 'darkgrid')
import numpy as np
import plotly.express as px
import warnings
warnings.filterwarnings('ignore')
import sklearn
from matplotlib.ticker import StrMethodFormatter
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression

data = pd.read_csv('/content/drive/MyDrive/Sleep_Analysis.csv')

data.head()

data.describe()

data.shape

data.info()

data.isnull().sum()

#duplicate rows
dp = pd.DataFrame(data)
duplicates = dp[dp.duplicated()]
print(duplicates)
data.duplicated().any()

data = data.drop(["meals/day","sleep direction","beverage","screen time", "sleep time"],axis=1)
data.head()

# Replacing YES or NO with 0 and 1 in data
data.replace(('yes','no','sometimes'),(1,0,1), inplace=True)
data.head()

data.replace(('Male','Female','Prefer not to say'),(0,1,0), inplace=True)
data.head()

def cleaner(dataframe):
    for i in dataframe.columns:
        if ((dataframe[i].isnull().sum() / dataframe.shape[0]) * 100) > 30:
            dataframe.drop(i, axis = 1, inplace = True)
        elif dataframe[i].dtypes == 'O':
            dataframe[i].fillna(dataframe[i].mode()[0], inplace = True)
        elif dataframe[i].dtypes == 'float' or dataframe[i].dtypes == 'int':
            dataframe[i].fillna(dataframe[i].median(), inplace = True)
    return dataframe.isnull().sum()


cleaner(data)

# Handle outliers, if they exist
def outlier(dataframe, a,b,c,d):
    plt.figure(figsize = (12, 3))
    plt.subplot(1,4,1)
    sns.boxplot(x = dataframe[a])
    plt.title(f"{a} boxplot")

    plt.subplot(1,4,2)
    sns.boxplot(x = dataframe[b])
    plt.title(f"{b} boxplot")

    plt.subplot(1,4,3)
    sns.boxplot(x = dataframe[c])
    plt.title(f"{c} boxplot")

    plt.subplot(1,4,4)
    sns.boxplot(x = dataframe[d])
    plt.title(f"{d} boxplot")

outlier(data, 'Age', 'exercise', 'physical illness', 'smoke/drink')

def outlierRemoval(dataframe):
    for i in dataframe.columns:
        lowerQuartile = dataframe[i].describe()[4]
        upperQuartile = dataframe[i].describe()[6]
        IQR = upperQuartile - lowerQuartile
        lowerIQR = lowerQuartile- 1.5 * IQR
        upperIQR = upperQuartile + 1.5 * IQR
        dataframe = dataframe.loc[(dataframe[i] >= lowerIQR) & (dataframe[i] <= upperIQR)]
    return dataframe

cat = data.select_dtypes(include = ['object', 'category'])
num = data.select_dtypes(include = 'number')

display(num.head(3))
display(cat.head(3))

plt.figure(figsize = (6,3))
sns.regplot(x = data.Age, y = data['sleep time'])

from matplotlib.ticker import StrMethodFormatter

print(data['sleep time'].value_counts())
data.hist(bins=50,figsize=[10,7])
print('Total time : ', data['sleep time'].sum())

#sleep_time = pd.crosstab(index = data['sleep time'], columns = data['physical illness'])
#print(sleep_time)
#corr = sleep_time.corr()
#corr.style.background_gradient(cmap='Blues')

sleep_time = pd.crosstab(index = data['sleep time'], columns = data['Age'])
print(sleep_time)
corr = sleep_time.corr()
corr.style.background_gradient(cmap='BuPu')

cat = data.select_dtypes(include = ['object', 'category'])
num = data.select_dtypes(include = 'number')

display(num.head(3))
display(cat.head(3))

from sklearn.preprocessing import StandardScaler, MinMaxScaler
scaler = StandardScaler()
normalizing = MinMaxScaler()

df = data.copy()

for i in df.drop(['sleep time'], axis = 1).columns:
    if df[i].dtypes == 'int' or df[i].dtypes == 'float':
        df[[i]] = scaler.fit_transform(df[[i]])
from sklearn.preprocessing import LabelEncoder
lb = LabelEncoder()
for i in df.columns:
    if df[i].dtypes == 'O':
        df[i] = lb.fit_transform(df[i])

df.head()

x = df.drop(['sleep time'], axis = 1)
y = df['sleep time']

from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import f_classif

best_feature1 = SelectKBest(score_func = f_classif, k = 'all')
fitting1 = best_feature1.fit(x,y)
scores1 = pd.DataFrame(fitting1.scores_)
columns1 = pd.DataFrame(x.columns)
feat_score1 = pd.concat([columns1, scores1], axis = 1)
feat_score1.columns = ['Feature', 'F_classif_score']
k1 = feat_score1.nlargest(11, 'F_classif_score')

k1.sort_values(by = 'F_classif_score', ascending = False)

from sklearn.preprocessing import StandardScaler, MinMaxScaler
scaler = StandardScaler()
normalizing = MinMaxScaler()

df = data.copy()

for i in df.drop(['smoke/drink'], axis = 1).columns:
    if df[i].dtypes == 'int' or df[i].dtypes == 'float':
        df[[i]] = scaler.fit_transform(df[[i]])
from sklearn.preprocessing import LabelEncoder
lb = LabelEncoder()
for i in df.columns:
    if df[i].dtypes == 'O':
        df[i] = lb.fit_transform(df[i])

df.head()

x = df.drop(['smoke/drink'], axis = 1)
y = df['smoke/drink']

from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import f_classif

best_feature1 = SelectKBest(score_func = f_classif, k = 'all')
fitting1 = best_feature1.fit(x,y)
scores1 = pd.DataFrame(fitting1.scores_)
columns1 = pd.DataFrame(x.columns)
feat_score1 = pd.concat([columns1, scores1], axis = 1)
feat_score1.columns = ['Feature', 'F_classif_score']
k1 = feat_score1.nlargest(11, 'F_classif_score')

k1.sort_values(by = 'F_classif_score', ascending = False)

import xgboost as xgb
model = xgb.XGBClassifier()
model.fit(x, y)


xgb.plot_importance(model)

import xgboost as xgb
model = xgb.XGBRegressor()
model.fit(x, y)


xgb.plot_importance(model)

import xgboost as xgb
model = xgb.XGBRegressor()
model.fit(x, y)


xgb.plot_importance(model)

sel_cols = ['Age', 'Gender', 'exercise', 'bluelight filter', 'physical illness']

x = df[sel_cols]
y =df['smoke/drink']

x.head()

from sklearn.model_selection import train_test_split
xtrain, xtest, ytrain, ytest = train_test_split(x, y, test_size = 0.20, random_state = 60, stratify = y)

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix
log_reg = LogisticRegression()

log_reg.fit(xtrain, ytrain)
train_pred = log_reg.predict(xtrain)
print(classification_report(train_pred, ytrain))

revealer = confusion_matrix(train_pred, ytrain)
plt.figure(figsize = (4,2))
sns.set(style = 'darkgrid')
sns.heatmap(revealer/np.sum(revealer), annot=True, cmap='crest', linewidth=5)

confusion_matrix(train_pred, ytrain)

import pickle
#---------------------SAVE MODEL-------------------------
pickle.dump(log_reg, open('SleepAnalysis.pkl', "wb"))

test_pred = log_reg.predict(xtest)
print(classification_report(test_pred, ytest))

revealer = confusion_matrix(test_pred, ytest)
plt.figure(figsize = (4,2))
sns.set(style = 'darkgrid')
sns.heatmap(revealer, annot=True, cmap='crest', linewidth=5)